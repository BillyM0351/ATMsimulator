#include <vector>
#include <string>
#include <cmath>
#include <cstdlib>
#include <iostream>
	using namespace std;

/*
hashMap class
parameters: N/A
return value: N/A
description: This class builds a custom map to handle the bank entries
*/
template <class t1, class t2>
class hashMap
{
public:
	// Default constructor that sets the size to 5
	hashMap(size_t = 5);
	// Bracket operator overload that implements find and insert
	t2& operator[](t1);
private:

	// A struct object that contains a (key, value) pair for each entry
	struct keyVal
	{
		keyVal()
		{
			key = t1();
			value = t2();
		}

		t1 key;
		t2 value;
	};

	// Function that resizes table 1 and table 2
	void resize(size_t);

	size_t hash1(string);
	size_t hash2(string);

	vector<keyVal> table1; // Hash table that stores a set of entries
	vector<keyVal> table2; // Hash table that stores a set of entries

	size_t items1; // A counter that indicates teh amount of entries currently stored in table1
	size_t items2; // A counter that indicates teh amount of entries currently stored in table2
};

/*
hashMap parameter constructor
parameters: Size
return value: N/A
description: This function initializes items1/items2 to 0 and resizes the tables to the parameter values
*/
template <class t1, class t2>
hashMap<t1, t2>::hashMap(size_t size)
{
	// Set items1 and items2 to 0
	items1 = 0;
	items2 = 0;

	// Resize tables with parameter value
	table1.resize(size);
	table2.resize(size);
	
}

/*
hashMap bracket operator overload
parameters: key
return value: N/A
description: Bracket operator function that implements find and insert
*/
template <class t1, class t2>
t2& hashMap<t1, t2>::operator[](t1 key)
{
	// If table is at or above 20% capacity then resize
	if (items1 >= table1.size()*.20 || items2 >= table2.size()*.20) {
		this->resize(table1.size());
	};
	
	// Compute index values
	bool loop = true;
	size_t index1 = hash1(key) % table1.size();
	size_t index2 = hash2(key) % table2.size();

	// Initialize collision counters to 0
	int i1, i2 = 0;

	// Store key into table
	while(loop == true) {

		if (table1[index1].key == "") {
			table1[index1].key = key;
			items1++;
			return table1[index1].value;
		};

		if (table1[index1].key == key) {
			return table1[index1].value;
		};

		if (table2[index2].key == "") {
			table2[index2].key = key;
			items2++;
			return table2[index2].value;
		};

		if (table2[index2].key == key) {
			return table2[index2].value;
		};

		i1++;
		i2++;

		// Regenerate index values if collision occurs
		if (i1 % 2 == 0) {
			index1 = (index1 + i1 * hash2(key)) % table1.size();
		} else {
			index1 = (index1 + i1 * hash1(key)) % table1.size();
		};

		if (i2 % 2 == 0) {
			index2 = (index2 + i2 * hash1(key)) % table2.size();
		} else {
			index2 = (index2 + i2 * hash2(key)) % table2.size();
		};
	};

	return table1[index1].value;
	
}

/*
hashMap resize function
parameters: amount
return value: N/A
description: This function resizes table1 and table2 by amount
*/
template <class t1, class t2>
void hashMap<t1, t2>::resize(size_t amount)
{

	// Create new tables and copy old tables into them
	vector<keyVal> newTable1;
	vector<keyVal> newTable2;

	newTable1 = table1;
	newTable2 = table2;

	// Clear old tables
	table1.clear();
	table2.clear();

	// Resize old tables
	table1.resize(amount*2);
	table2.resize(amount*2);

	// Copy back over the elements into the original tables
	for (int i = 0; i < newTable1.size(); i++) {
		if (newTable1[i].key != "") {
			(*this)[newTable1[i].key] = newTable1[i].value;
		};
	};

	for (int i = 0; i < newTable2.size(); i++) {
		if (newTable2[i].key != "") {
			(*this)[newTable2[i].key] = newTable2[i].value;
		};
	};

	// Clear new tables
	newTable1.clear();
	newTable2.clear();

}

/*
hashMap hash1 function
parameters: key
return value: index value generated by key
description: Returns a value for a given key
*/
template <class t1, class t2>
size_t hashMap<t1, t2>::hash1(string key)
{
	size_t keyVal = 0;

	for (int i = 0; i < key.size(); i++) {
		keyVal += key[i] * pow(10, i);
	};

	return keyVal;
}

/*
hashMap hash2 function
parameters: key
return value: index value generated by key
description: Returns a value for a given key
*/
template <class t1, class t2>
size_t hashMap<t1, t2>::hash2(string key)
{

	size_t keyVal = 0;
	int j = 0;

	for (int i = key.size()-1; i > -1; i--) {
		keyVal += key[i] * pow(10, j);
		j++;
	}

	return keyVal;

}
